# cpp_stl
**C++ STL示例代码**

01. sort() 排序  
02. stable_sort() 排序（稳定）  
03. partial_sort() 获取最大/小的指定数量的元素，例如100000个数字中最大的10个  
04. nth_element() 找到第几大/小的元素，例如100000个数字中第10大的元素  
05. is_sorted() 判断容器中的元素是否有序  
	is_sorted_until() 判断容器中的元素是否有序，返回一个迭代器：如果有序返回end()，如果无序返回指向第一个破坏有序性的元素的迭代器  
06. 如何选择排序函数？  
	当需要对普通数组或者 array、vector 或者 deque 容器中的元素进行排序时，怎样选择最合适（效率最高）的排序函数：  
	如果需要对所有元素进行排序，则选择 sort() 或者 stable_sort() 函数；  
	如果需要保持排序后各元素的相对位置不发生改变，就只能选择 stable_sort() 函数，而另外 3 个排序函数都无法保证这一点；  
	如果需要对最大（或最小）的 n 个元素进行排序，则优先选择 partial_sort() 函数；  
	如果只需要找到最大或最小的 n 个元素，但不要求对这 n 个元素进行排序，则优先选择 nth_element() 函数。  
	四个函数性能之间的比较：nth_element() > partial_sort() > sort() > stable_sort()       <--从左到右，性能由高到低  
08. merge() 将 2 个有序序列合并为 1 个有序序列，前提是这 2 个有序序列的排序规则相同（要么都是升序，要么都是降序）。得到的新有序序列的排序规则和这 2 个有序序列相同。  
	inplace_merge() 当 2 个有序序列存储在同一个数组或容器中时，如果想将它们合并为 1 个有序序列，更推荐使用 inplace_merge() 函数  
09. find() 用于在指定范围内查找和目标元素值相等的第一个元素
	例：auto it = find(v.begin(), v.end(), 15);
10. 手动编写循环结构和调用 STL 算法函数相比，哪种实现方式更好呢？毫无疑问，直接调用算法会更好，理由有以下几个：  
	算法函数通常比自己写的循环结构效率更高；  
	自己写循环比使用算法函数更容易出错；  
	相比自己编写循环结构，直接调用算法函数的代码更加简洁明了。  
	使用算法函数编写的程序，可扩展性更强，更容易维护  
11. STL算法和容器中的成员方法同名时，该如何选择？  
	STL 标准库提供有 70 多种算法函数，其中有些函数名称和 STL 容器模板类中提供的成员方法名相同。  
	例如，STL 标准库提供了 sort() 和 merge() 函数（属于std::），而 list 容器模板类中也提供有同名的 sort() 和 merge() 成员方法。再比如，STL 标准库提供有 count()、find()、lower_bound()、upper_bound() 以及 equal_range() 这些函数，而每个关联式容器（除哈希容器外）也提供有相同名称的成员方法。  
	当某个 STL 容器提供有和算法同名的成员方法时，应该使用哪一个呢？大多数情况下，我们应该优先使用 STL 容器提供的成员方法，而不是同名的 STL 算法，原因包括：  
	虽然同名，但它们的底层实现并不完全相同。相比同名的算法，容器的成员方法和自身结合地更加紧密。  
	相比同名的算法，STL 容器提供的成员方法往往执行效率更高。  
12. find_if() 函数用于查找符合谓词函数规则的第一个元素，而 find_if_not() 函数则用于查找第一个不符合谓词函数规则的元素。  
	例：auto it = find_if(v.begin(), v.end(), cmp);  
13. find_end() 在序列 A 中查找序列 B 最后一次出现的位置(也可以自定义规则) 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向A中查找到的第一个元素；反之，如果查找失败，则该迭代器的指向序列A的end()  
	例：  
	vector<int> A = {1, 2, 3, 4, 8, 12, 18, 1, 2, 3};  
	vector<int> B = { 1, 2, 3 };  
	auto it = find_end(A.begin(), A.end(), B.begin(), B.end());  
14. find_first_of() 函数在 A 序列中查找和 B 序列中任意元素相匹配的第一个元素(也可以自定义规则)  
	例：  
	vector<int> A = {1, 7, 11, 15, 35, 3, 8, 12, 28, 33, 39};  
	vector<int> B = {14, 15, 16};  
	auto it = find_first_of(A.begin(), A.end(), B.begin(), B.end());  
15. adjacent_find() 函数用于在指定范围内查找 2 个连续相等的元素  
	例：auto it = adjacent_find(v.begin(), v.end());  
16. search() 函数的功能恰好和 find_end() 函数相反，用于在序列 A 中查找序列 B 第一次出现的位置  
17. 和 search() 一样，search_n() 函数也用于在指定区域内查找第一个符合要求的子序列。不同之处在于，前者查找的子序列中可包含多个不同的元素，而后者查找的只能是包含多个相同元素的子序列。  
	例1：auto it = search_n(v1.begin(), v1.end(), 3, 4); 在v1中查找连续3个4，返回第一个4的位置  
	例2：auto it = search_n(v2.begin(), v2.end(), 3, 11, cmp); 查找3个连续的元素，它们每一个都能在cmp(该元素,11)执行时返回true  